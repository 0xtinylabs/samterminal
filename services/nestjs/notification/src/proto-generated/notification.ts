// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.4
// source: notification.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export const protobufPackage = "notification";

export enum NotificationType {
  TELEGRAM = "TELEGRAM",
  FARCASTER = "FARCASTER",
}

export enum TelegramBotTypes {
  MAIN = "MAIN",
  USER = "USER",
}

export enum NotificationButtonType {
  LINK = "LINK",
  FUNCTION = "FUNCTION",
}

export enum SyncBotToUserStatus {
  CODE_NOT_CORRECT = "CODE_NOT_CORRECT",
  USER_NOT_FOUND = "USER_NOT_FOUND",
  SYNCED = "SYNCED",
}

export interface NotificationButton {
  label: string;
  data?: string | undefined;
  type: NotificationButtonType;
}

export interface BotState {
  type: NotificationType;
  isActive: boolean;
}

export interface NotificationExtrasType {
  buttons: NotificationButton[];
}

export interface SendNotificationRequest {
  message: string;
  type: NotificationType;
  botName: TelegramBotTypes;
  extras?: NotificationExtrasType | undefined;
  to: string;
  bypass?: boolean | undefined;
}

export interface SendNotificationResponse {
  success: boolean;
}

export interface GetUserBotURLRequest {
  userId: string;
}

export interface UserBotData {
  code: string;
  url: string;
  type: NotificationType;
}

export interface GetUserBotURLResponse {
  urls: UserBotData[];
}

export interface GetUserBotStatesRequest {
  userId: string;
}

export interface GetUserBotStatesResponse {
  success: boolean;
  botStates: BotState[];
}

export interface ToggleBotStateRequest {
  userId: string;
  type: NotificationType;
}

export interface ToggleBotStateResponse {
  success: boolean;
  botStates: BotState[];
}

export const NOTIFICATION_PACKAGE_NAME = "notification";

export interface NotificationServiceClient {
  send(request: SendNotificationRequest): Observable<SendNotificationResponse>;

  getUserBotUrl(request: GetUserBotURLRequest): Observable<GetUserBotURLResponse>;

  getUserBotStates(request: GetUserBotStatesRequest): Observable<GetUserBotStatesResponse>;

  toggleBotState(request: ToggleBotStateRequest): Observable<ToggleBotStateResponse>;
}

export interface NotificationServiceController {
  send(
    request: SendNotificationRequest,
  ): Promise<SendNotificationResponse> | Observable<SendNotificationResponse> | SendNotificationResponse;

  getUserBotUrl(
    request: GetUserBotURLRequest,
  ): Promise<GetUserBotURLResponse> | Observable<GetUserBotURLResponse> | GetUserBotURLResponse;

  getUserBotStates(
    request: GetUserBotStatesRequest,
  ): Promise<GetUserBotStatesResponse> | Observable<GetUserBotStatesResponse> | GetUserBotStatesResponse;

  toggleBotState(
    request: ToggleBotStateRequest,
  ): Promise<ToggleBotStateResponse> | Observable<ToggleBotStateResponse> | ToggleBotStateResponse;
}

export function NotificationServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["send", "getUserBotUrl", "getUserBotStates", "toggleBotState"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("NotificationService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("NotificationService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const NOTIFICATION_SERVICE_NAME = "NotificationService";
